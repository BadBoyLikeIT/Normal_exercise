1.c/c++中的关键字
1.1const 用于定义一个有类型的只读常变量。位于只读数据段，第一次使用时为其分配内存。
可定义变量、指针、函数
const基础
       int b = 500;
       const int* a = &b;               [1]
       int const *a = &b;               [2]
       int* const a = &b;               [3]
       const int* const a = &b;         [4]
    如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。因此1和2的情况相同，都是指针所指向的内容为常量，这种情况下不允许对内容进行更改操作，如不能*a = 3 ；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。
eg  int a=1,b=2;
    int const c = 3;
    const int *d = &b;
    int *const e=&b;

	c = 4; no
    *d = 4;no
    d = &a;yes
    *e = 5; yes  //哪里被限定，哪里不能变。
const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放，例如：val_c；const局部变量存储在栈中，代码块结束时释放，例如：val_j。

1.2static ：编译初期为其分配内存。
链接属性：变成内部，只能由被定义的源文件的内容进行操作。
存储属性：变成静态内存存储，生命周期为整个程序运行周期。
eg：全局变量+static 限制其只能被源文件中操作。
	局部变量+static 改变其为静态内存，生存周期为整个程序，作用域不变。
	静态函数速度会快，作用域只限于本文件。可以避免同名的问题。
1.3violate 因为多线程共享数据，数据可能随时在变化，优化器在读数时需要每次从内存中读取。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值(From Memory)，而不是使用保存在寄存器里的备份。 
int i=10;  
int j = i； //(1)语句  
int k = i；//(2)语句  
这时候编译器对代码进行优化，因为在(1)、(2)两条语句中，i 没有被用作左值。这时候编译器认为i 的值没有发生改变，所以在(1)语句时从内存中取出i 的值赋给j 之后，这个值并没有被丢掉，而是在(2)语句时继续用这个值给k赋值。编译器不会生成出汇编代码重新从内存里取i 的值，这样提高了效率。但要注意：(1)、(2)语句之间i 没有被用作左值才行。
再看另一个例子：
volatile int i=10;  
int j = i； //(3)语句  
int k = i；//(4)语句 
volatile 关键字告诉编译器i 是随时可能发生变化的，每次使用它的时候必须从内存中取出i的值，因而编译器生成的汇编代码会重新从i 的地址处读取数据放在k 中。这样看来，如果i是一个寄存器变量或者表示一个端口数据或者是多个线程的共享数据，就容易出错，所以说volatile 可以保证对特殊地址的稳定访问。
1.4inline 内联函数 栈指针被代码替换，高频率出现的函数，减少跳转。

#define是宏定义，是在编译期间对定义的变量进行直接文本替换，不做类型检查。
const int Months = 12；

2.malloc/free 与new/delete区别：
	1.malloc/free是c的库函数，而new/delete是c++操作符
	2.new/delete能够管理对象的内存分配与释放。
	3.new操作会调用对象的构造函数并初始化内存区域。而malloc只是申请。
	free或delete只是释放了指针指向的内存，指针的值还是这块内存地址。
3.常见类型的sizeof()
  short 2;int 4;char 1;指针 4


4.序存储空间布局

C语言一直有下列部分组成：

正文段 － CPU 执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外而修改自身指令；

初始化数据段(数据段) － 在程序中所有赋了初值的全局变量，存放在这里。

非初始化数据段(bss段) － 在程序中没有初始化的全局变量；内核将此段初始化为0；

栈 － 增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息(返回地址；环境信息)。

堆heap － 动态分配存储
5.虚函数与纯虚函数
  内存分配模型中，增加虚函数表。
  单继承 多重继承 
  多继承 有多个虚函数表
6.内存泄漏
  动态申请的内存，没有free/delete,就会造成内存泄漏
7.野指针
  没有初始化的指针
  返回局部变量的地址；因为程序会被销毁，进而指针指向一个已经被回收的内存。
8.继承下构造函数执行顺序
  从左到右依次执行
9.智能指针 指针会智能释放 在离开其作用域后
  STL为我们提供了四种智能指针
  auto_ptr 会出现重复删除的问题
  unique_ptr、shared_ptr、weak_ptr
10.重载 就是同名、返回值相同、参数列表不同

算法：
经典的排序算法：
交换排序：冒泡排序 O(n2) O(1)
          快排 分成一边一边 之后递归 O(nlog2n) O(nlog2n) 改进轴的选取方式 左 中 右的中值来改进
选择排序 选最小交换 O(n2) O(1)
归并排序 分治归并   O(nlog2n) O(n)
hash冲突解决：
线性法、拉链法、再hash
二叉排序树：二叉搜索、AVL平衡二叉树
红黑树：改进了的avl
SQL优化：嵌套查询变成连接查询、建立合适的索引、分析sql执行计划(explain)

计算机网络：
TCP拥塞控制：
1.慢开始
2.拥塞避免
3.快重传
4.快恢复

操作系统：
进程间通信：
1.管道 流控制 先进先出
2.信号 ctrl+c
3.消息队列
4.共享内存
5.套接字

内存对齐：
1.目的：防止一个数据需要在两个内存读取周期中才能读取完
2.原则：按最大的来对齐。
传值、传址、引用：
传址其实原理还是传值，只不过传的是地址变量。因为是地址变量所以是独立的。
引用：其实使用的是别名，传递的也还是地址。

红黑树：
着色了的二叉排序树
1）每个结点要么是红的，要么是黑的。  
2）根结点是黑的。  
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 
稳定：o(logn)

#include <stdio.h>
int main()
{
    char buf[10] = {0};  //将buf[10] 全部初始化为0
    for(int i=0;i<10;i++)
        printf("%d ",buf[i]);

}


extern 作用 
引用外部文件的全局变量
::可以代表全局的意思
c++中直接在.h部分中给出了定义
static string enBase64(const string &inbuf);
int main(int argv,char * argv[]); //参数的意义
模板类 template<>

static 函数的作用()
可以直接通过::来访问，类在加载的时候就会被分配内存，而非静态成员属于类的对象，只有类的对象产生时才会分配内存，然后通过类的实例去访问。无法访问类的非静态数据成员。 
说静态成员函数没有对象也可调用。但他们都是在编译期就进行地址绑定的。
虚拟成员函数与他们的区别在于虚拟函数是对象生成时由对象的虚表决定的（所以是动态的）。
静态关联与动态关联
初始化列表：
1.按照声明顺序进行先后初始化；而不是按照列表的顺序
2.对于const、引用来说只能用初始化列表的方式进行初始化。


虚函数
父类的指针指向不同子类的对象，从而实现多态。
虚基类：防止被多次继承。
纯虚函数：只定义未实现。
继承的过程中：变量也被继承了。
例子：server->archive/RecyclebinArchiveController中的run函数

#include <iostream>
using namespace std;

class A
{
public:
    virtual void out1()=0;  ///由子类实现 纯虚函数
    virtual ~A(){};
    virtual void out2() ///默认实现
    {
        cout<<"A(out2)"<<endl;
    }
    void out3() ///强制实现
    {
        cout<<"A(out3)"<<endl;
    }
};

class B:public A
{
public:
    virtual ~B(){};
    void out1()
    {
        cout<<"B(out1)"<<endl;
    }
    void out2()
    {
        cout<<"B(out2)"<<endl;
    }
    void out3()
    {
        cout<<"B(out3)"<<endl;
    }
};

int main()
{
    A *ab=new B; //不能直接new A;
    ab->out1();
    ab->out2();
    ab->out3();
    cout<<"************************"<<endl;
    B *bb=new B;
    bb->out1();
    bb->out2();
    bb->out3();

    delete ab;
    delete bb;
    return 0;
}

正常的函数在编译、链接之后就会形成一个静态的地址，而虚函数可以形成一个动态的地址。

extern "C"
1.兼容C，链接的时候回去obj找对应的函数名，C++支持重载函数名称会与其不同，如果直接写的话找不到对应的名称，而导致链接错误。
virtual 函数为什么可以直接在头文件中定义

数组指针与指针数组：
char * p[]; //指针数组  
char (*p)[]; //数组指针
解释：因为[]的优先级很高，所以p[]相结合，而char *变成了数据类型。

print("%p\n",pointer); //强制输出一波


sprintf/strcpy/strcat/strcmp
字符数组转换成字符串
char ch[] = "asdkfjll";
string str = ch;
字符串转换成字符数组
char buf[10];
string str = "adfjk";
strcpy(buf,str.c_str());